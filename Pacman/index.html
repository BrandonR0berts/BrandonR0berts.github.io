<!DOCTYPE HTML>

<html>
	<head>
		<title>Pacman</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper-->
			<div id="wrapper">

				<!-- Nav -->
					<nav id="nav">
						<a href="#" class="icon solid fa-home"><span>Main</span></a>
						<a href="#work" class="icon solid fa-folder"><span>Images</span></a>
						<a href="#contact" class="icon solid fa-envelope"><span>Gameplay</span></a>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Me -->
							<article id="home" class="panel intro">
								<header>
									<h1>Pacman</h1>
									<p>Re-creation Of Pacman For My First Year Of University</p>
								</header>
							</article>

						<!-- Work -->
							<article id="work" class="panel">
								<header>
									<h2><u>Gameplay Images</u></h2>
								</header>
		
								<section>
									<div class="row">
										<div class="col-4 col-6-medium col-12-small">
											<a class="image fit"><img src="images/MainMenuPacman.png" alt=""></a>
										</div>
										<div class="col-4 col-6-medium col-12-small">
											<a class="image fit"><img src="images/Inky.png" alt=""></a>
										</div>
										<div class="col-4 col-6-medium col-12-small">
											<a class="image fit"><img src="images/BlinkyMainMenu.png" alt=""></a>
										</div>
										<div class="col-4 col-6-medium col-12-small">
											<a class="image fit"><img src="images/Pinky.png" alt=""></a>
										</div>
										<div class="col-4 col-6-medium col-12-small">
											<a class="image fit"><img src="images/Clyde.png" alt=""></a>
										</div>
										<div class="col-4 col-6-medium col-12-small">
											<a class="image fit"><img src="images/HighScorePacman.png" alt=""></a>
										</div>
										<div class="col-4 col-6-medium col-12-small">
											<a class="image fit"><img src="images/InGameExample1.png" alt=""></a>
										</div>
										<div class="col-4 col-6-medium col-12-small">
											<a class="image fit"><img src="images/InGameExample2.png" alt=""></a>
										</div>
										<div class="col-4 col-6-medium col-12-small">
											<a class="image fit"><img src="images/InGameExample3.png" alt=""></a>
										</div>
									</div>
								</section>
							</article>

						<!-- Contact -->
							<article id="contact" class="panel">
								<header style="text-align:centre">
									<h2> <u>Main Concepts Developed</u></h2>
								</header>
								
								<header1 style="text-align:centre">
									<b><u>    Overview:</u></b>
								</header1>
								
								<p>
									This project was developed as a level 4, first semester, graphics module submission. This submission required usage of a university owned framework to create Pacman, or a very similar game. </br>
									As this was developed using an internal framework I has therefore never seen the framework code or structure before, forcing me to work initially out of my comfort zone and adapt to the new system. Despite this though I was able to re-create the majority of the arcade version of Pacman, with the only exceptions of the between level animations, and the starting main menu screen. 
									This was due to the time frame restruction of the first semester.
								</p>
								
								<header2 style="text-align:centre">
									<b><u>    Loading In Rendering Level Data From Files:</u></b>
								</header2>
								
								<p>
									One of my main aims whilst developing this project was to have all levels support being fully customised through just changing a text file, and maybe a sprite sheet. 
									Therefore, during the initial development stages I focused on not hard coding as much of the game as I could. The result from this is that a text file, within a folder named 'BackgroundMaps', that maps the sprite indexes of sprite sheets found in the directory 'Textures/Backgrounds', to the screen. </br>
									This mapping of textures results in the following images mapping to each other, depending on which sprite sheet you use: </br>
								</p>
		
								<div class="row">
									<div class="col-4 col-4-medium col-12-small">
										<a class="image fit"><img src="images/BackgroundIndexMappingFile.png"></a>
									</div>

									<div class="col-4 col-4-medium col-12-small">
										<a class="image fit"><img src="images/MazeParts0.png"></a>
										<a class="image fit"><img src="images/MazeParts1.png"></a>
										<a class="image fit"><img src="images/MazeParts2.png"></a>
									</div>
									
									<div class="col-4 col-4-medium col-12-small">
										<a class="image fit"><img src="images/ExampleBackground.png"></a>
									</div>
								</div>
								
								<header4 style="text-align:centre">
									<b><u>    Enviroment collisions:</u></b>
								</header4>
								
								<p>
									Of all the concepts created for this project, handling collision and player movement was by far the most complex of them all. And both of these concepts required enviroment collisions, making this area vital to the final game. During development there were many pitfalls along the way, however the final result ended up behaving exactly as intended, if not how I initally planned it. </br> </br>
									First of all there needed to be a way to set the collision for the level, that also aligns with the plan to make the levels almost fully customisable. Due to this the collision couldn't be hardcoded, as it would defeat the point of doing the prior texture index mapping work.
									My solution was to have a seperate folder named 'CollisionMaps', and to put collision data text files in there. Referencing from these text files allows for specific collision maps to be made for individial levels, allowing them to be fully customisable. </br> </br>
									Loading this data and storing it into the program was not difficult, however, ensuring that the character moving around the level, be it a ghost or pacman, is always in the centre of the current row/column was a harder task than initially anticipated.
									To solve this the character, whenever they change direction, is set to be in the centre of the axis perpendicular to the one they are going to be traveling along. And in order for them to change direction they must be within a certain distance of the centre of their grid square, this ensures that there is no obvious snapping to the new orientation or position. </br> </br>
		
									With this in place there were still some minior bugs, such as if the player presses two valid opposing directions at once, then they would thrash beteen the two directions. And if the player is in a corner and pressing two directions, one to leave the corner and one to remain. Then it was possible that the direction that prevents the player from moving would have been chosen, leaving the player stuck in a corner. </br>
									In order to remedy this a check was added so that whenever the player chooses a direction to go the new direction is determined to be valid. If the direction is not valid then the input is ignored. This solves the problem of being stuck in a corner, but not the problem of one axis being prioritised over the other. </br> </br>
									To solve this I simply prioritised the current movement direction over a change in direction. So if the player is going right and is pressing right and left, the player will continue to move right. This is up until they release their movement direction, or until they hit a wall, which would cause their right movement to become invalid and they would start moving left.
								</p>
								
								<header5 style="text-align:centre">
									<b><u>    AI Ghosts:</u></b>
								</header5>
								
								<p>
                                                                    In the original Pacman the four ghosts all have similar, yet slightly different behaviours. This difference in behaviour is the position that they are trying to get to. With the notable exception of the orange ghost, who just travels randomly around the screen. </br>
                                                                    In this re-creation I had the ghosts achieve this behaviour, as well as constantly adapting to the enviroment, through use of a stack based finite state machine. This system is like a finite state machine, with the notable exception of having a stored stack of current states instead of just one. This allows for new situations to arise, such as Pacman eating a power pill, and the previous state to be saved. </br> </br>
    
                                                                    <b><u>Flee:</b></u> </br>
									Whenever the player, if they are playing as Pacman, collects a powerup, then this state is pushed to the stack. In this state the ghost returns to a corner of the maze. This corner is different per ghosts colour, but the position they are heading towards is an impossible to reach position. The result of this is the ghosts circling around an area in a corner. </br>
									In practice the ghosts normally don't spend long enough in their respective corners for this behaviour to be obvious. But it does give the impression of ghosts fleeing Pacman. </br> 
									Here are the states the ghosts can be in:</br> </br>


                                                                    <b><u>Chase:</b></u> </br>
									This is the base state for the Ghosts, so that if nothing special is happening in the game, then their goal is always being followed. </br> </br>
                                                                    <b><u>Return home:</b></u> </br>
									This state just has the Ghost return to a set position in the maze. The position that is set to be their home is not accessable by Pacman, giving the visual impression of security for the ghosts. </br> </br>
                                                                    <b><u>Exit home: </b></u></br>
									This state is only entered when the return home state has completed. Within this state the Ghost is directed towards their home's entrance. Upon reaching this position this state is instantly popped off the stack. </br>
                                                                    </br>One key point that applies to all AI in this project is the 'move to here' code. This code is notable as it is very possible for characters to become stuck in a corner, or to not change their axis when they should. Resulting in them never reaching their target position. </br>
                                                                    In order to fix this issue the AI characters must never stop moving. Meaning that if they hit a wall then they must choose the next best direction for them to travel. This direction is calculated through determining which axis the character is further away from their target in. And then determining if they can go in that axis.
								</p>
								
								<header6 style="text-align:centre">
									<b><u>    AI Pacman:</u></b>
								</header6>
								
								<p>
									Developing the AI for pacman was very similar to creating the ghost's AI. </br>
									Firstly, they both used a stack based FSM. Therefore there were no new concepts required to be developed in order to get Pacman moving around the screen on his own. However, as the goals Pacman wanted to achieve were different to the Ghosts then he was required to use different states, to allow for different behaviour. This behaviour was: </br> </br>
									<b><u>Collect Dots:</b></u> </br>
									This is the base state, so that if Pacman was in no danger then he would always continue to achieve the objective of the game (from his perspective). </br> </br>
									<b><u>Flee Ghosts: </b></u></br>
									If any ghosts came within a certain distance of Pacman then he would prioritise getting away from the Ghosts over collecting dots. If he is in this state and comes within a certain distance of a power up then he adds the state of collect power up to the stack. At the point that that Pacman is no-longer near any ghosts then this state is popped off the stack.</br> </br>
									<b><u>Chase Ghosts:</b></u> </br>
									In this state Pacman will go towards the position of the closest ghost that is fleeing him, as chasing a ghost that could do him damage would make no sense. At the point that the power up runs out then this state is popped off the stack. </br> </br>
									<b><u>Collect Power Up:</b></u> </br>
									When in this state Pacman will go towards the closest power up, if there is one remaining. If there are no powerups remaining then this state is popped off the stack.</br> </br>

									Secondly, they both were inherited from the same base class - which contains the collision and movement functionality. So making Pacman move to a certain point in the map was as simple as calling the same function the Ghosts were using. </br> </br>
									
									And finally, getting the AI to control Pacman instead of a Ghost was as simple as making the player controls affect a ghost, and setting that this character should follow its FSM instead of player controls.
								</p>							
							</article>

					</div>

				<!-- Footer -->
					<div id="footer">
						<ul class="copyright">
							<li>Brandon Roberts 2021</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
						</ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
